{"version":3,"file":"audio-helpers.js","sourceRoot":"","sources":["../../src/audio-helpers.ts"],"names":[],"mappings":"AACA,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,KAAW,EAAE,cAAsB,EAAU,EAAE;IACzE,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE;QAC3B,IAAI;YACF,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;gBACjD,OAAO,CAAC,GAAG,CAAC,+BAA+B,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;gBACzD,OAAO,CAAC,GAAG,cAAc,EAAE,KAAK,CAAC,CAAC;aACnC;SACF;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,CAAC,IAAI,CAAC,0BAA0B,EAAE,KAAK,CAAC,CAAC;SACjD;KACF;SAAM;QACL,OAAO,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;KACjD;IAED,OAAO,cAAc,CAAC;AACxB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,MAAc,EAAE,QAAgB,EAAQ,EAAE;IACnE,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAE3D,IAAI;QACF,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC,CAAC;QAClD,OAAO,CAAC,GAAG,CAAC,sCAAsC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QAC/D,OAAO,IAAI,CAAC;KACb;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,IAAI,CAAC,8DAA8D,CAAC,CAAC;QAC7E,MAAM,YAAY,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC,CAAC;QAC9D,OAAO,CAAC,GAAG,CAAC,kCAAkC,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC;QACnE,OAAO,YAAY,CAAC;KACrB;AACH,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,KAAK,EAAE,aAA4B,EAAiB,EAAE;IACpF,IAAI;QACF,aAAa,CAAC,WAAW,EAAE,CAAC;QAC5B,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC;QAEvD,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAC;KAC9C;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,IAAI,CAAC,6BAA6B,EAAE,KAAK,CAAC,CAAC;KACpD;AACH,CAAC,CAAC","sourcesContent":["\r\nexport const handleChunk = (chunk: Blob, existingChunks: Blob[]): Blob[] => {\r\n  if (chunk && chunk.size > 0) {\r\n    try {\r\n      if (chunk.type && chunk.type.startsWith('audio/')) {\r\n        console.log('Adding valid chunk with size:', chunk.size);\r\n        return [...existingChunks, chunk];\r\n      }\r\n    } catch (error) {\r\n      console.warn('Chunk validation failed:', error);\r\n    }\r\n  } else {\r\n    console.warn('Received empty or invalid chunk');\r\n  }\r\n  \r\n  return existingChunks;\r\n};\r\n\r\nexport const createBlob = (chunks: Blob[], mimeType: string): Blob => {\r\n  console.log('Creating blob from', chunks.length, 'chunks');\r\n  \r\n  try {\r\n    const blob = new Blob(chunks, { type: mimeType });\r\n    console.log('Blob created successfully with size:', blob.size);\r\n    return blob;\r\n  } catch (error) {\r\n    console.warn('Blob creation failed with primary mime type, trying fallback');\r\n    const fallbackBlob = new Blob(chunks, { type: 'audio/webm' });\r\n    console.log('Fallback blob created with size:', fallbackBlob.size);\r\n    return fallbackBlob;\r\n  }\r\n};\r\n\r\nexport const ensureFinalChunk = async (mediaRecorder: MediaRecorder): Promise<void> => {\r\n  try {\r\n    mediaRecorder.requestData();\r\n    await new Promise(resolve => setTimeout(resolve, 150));\r\n    \r\n    console.log('Final chunk request completed');\r\n  } catch (error) {\r\n    console.warn('Final chunk request failed:', error);\r\n  }\r\n}; "]}